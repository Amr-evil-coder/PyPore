{"name":"Pypore","tagline":"Tools used to analyze data from nanopore-based experiments.","body":"# PyPore\r\n## _Analysis of Nanopore Data_\r\n\r\nThe PyPore package is based off of a few core data analysis packages in order to provide a consistent and easy framework for handling nanopore data in the UCSC nanopore lab. The packages it requires are:\r\n\r\n* numpy\r\n* scipy\r\n* matplotlib\r\n* sklearn\r\n\r\nPackages which are not required, but can be used, are:\r\n\r\n* mySQLdb\r\n* cython\r\n* PyQt4\r\n\r\nLet's get started!\r\n\r\n# Files\r\n\r\nNanopore data files consist primarily of current levels corresponding to ions passing freely through the nanopore (\"open channel\"), and a blockages as something passes through the pore, such as a DNA strand (\"events\"). Data from nanopore experiments are stored in Axon Binary Files (extension .abf), as a sequence 32 bit floats, and supporting information about the hardware. They can be opened and loaded with the following:\r\n\r\n```\r\nfrom PyPore.DataTypes import *\r\nfile = File( \"My_File.abf\" ) \r\n```\r\n\r\nThe File class contains many methods to simplify the analysis of these files. The simplest analysis to do is to pull the events, or blockages of current, from the file, while ignoring open channel. Let's say that we are looking for any blockage of current which causes the current to dip from an open channel of ~120 pA. To be conservative, we set the threshold the current has to dip before being significant to 110 pA. This can be done simply with the file's parse method, which requires a parser class which will perform the parsing. The simplest event detector is the *lambda_event_parser, which has a keyword *threshold, indicating the raw current that serves as the threshold. \r\n\r\n```\r\nfrom PyPore.DataTypes import *\r\nfile = File( \"My_File.abf\" )\r\nfile.parse( parser=lambda_event_parser( threshold=110 ) ) \r\n```\r\n\r\nThe events are now stored as Event objects in file.events. The only other important file methods involve loading and saving them to a cache, which we'll cover later. Files also have the properties mean, std, and n (number of events). \r\n\r\n# Events\r\n\r\nEvents are segments of current which correspond to something passing through the nanopore. We hope that it is something which we are interested in, such as DNA or protein. An event is usually made up of a sequence of discrete segments of current, which should correspond to reading some region of whatever is passing through. In the best case, each discrete segment in an event corresponds to a single nucleotide of DNA, or a single amino acid of a protein passing through.\r\n\r\nEvents are often noisy, and transitions between them are quick, making filtering a good option for trying to see the underlying signal. Currently only [bessel filters](http://en.wikipedia.org/wiki/Bessel_filter) are supported for filtering tasks, as they've been shown to perform very well.\r\n\r\nLet's continue with our example, and imagine that now we want to filter each event, and look at it! The filter method has two parameters, order and cutoff, defaulting to order=1 and cutoff=2000. (Note that we now import pyplot as well.)\r\n\r\n```\r\nfrom PyPore.DataTypes import *\r\nfrom matplotlib import pyplot as plt\r\n\r\nfile = File( \"My_File.abf\" )\r\nfile.parse( parser=lambda_event_parser( threshold=110 ) ) \r\n\r\nfor event in file.events:\r\n    event.filter( order=1, cutoff=2000 )\r\n    event.plot()\r\n    plt.show()\r\n```\r\n\r\nThe plot command will draw the event on whatever canvas you have, allowing you to make subplots with the events or add them into GUIs (such as Abada!), with the downside being that you need to use plt.show() after calling the plot command. The plot command wraps the pyplot.plot command, allowing you pass in any argument that could be used by pyplot.plot, for example:\r\n\r\n```\r\nevent.plot( alpha=0.5, marker='o' ) \r\n```\r\n\r\nThe next step is usually to try to segment this event into it's discrete states. There are several segmenters which have been written to do this, of which currently *StatSplit is the best, written by Dr. Kevin Karplus and based on a recursive maximum likelihood algorithm.  This algorithm was sped up by rewritting it in Cython, leading to *SpeedyStatSplit, which is a python wrapper for the cython code. Segmenting an event is the same process as detecting events in a file, by using the parse method on an event and passing in a parser.\r\n\r\nLet's say that now we want to segment an event and view it. Using the same plot command for the event, we can specify to color by 'cycle', which colors the segments in a four-color cycle for easy viewing. SpeedyStatSplit takes in several parameters, of which *min_gain_per_sample is the most important, and 0.50 to 1.50 usually provide an adequate level to parse at, with higher numbers leading to less segments. \r\n\r\n```\r\nfrom PyPore.DataTypes import *\r\nfrom matplotlib import pyplot as plt\r\n\r\nfile = File( \"My_File.abf\" )\r\nfile.parse( parser=lambda_event_parser( threshold=110 ) ) \r\n\r\nfor event in file.events:\r\n    event.filter( order=1, cutoff=2000 )\r\n    event.parse( parser=SpeedyStatSplit( min_gain_per_sample=0.50 ) )\r\n    event.plot( color='cycle' )\r\n    plt.show()\r\n```\r\n\r\nThe last core functionality is the ability to apply an hidden markov model (HMM) to an event, and see which segments correspond to which hidden states. Any hmm (or more complex model!) can be used as long as it has a predict method (like sklearn hmms), but the PyPore.hmm module gives a core class, NanoporeHMM, and several examples, of how to make an hmm that will be useful. Let's say that we're dealing with an event that appears to switch between a high current state and a low current state, corresponding to a DNA strand ratcheting back and forth between two nucleotides. In order to try to group these segments, I've written an HMM named Bifurcator which will classify these segments as belonging to one group or the other. I want to visualize it's performance! \r\n\r\n```\r\nfrom PyPore.DataTypes import *\r\nfrom PyPore.hmm import Bifurcator\r\nfrom matplotlib import pyplot as plt\r\n\r\nfile = File( \"My_File.abf\" )\r\nfile.parse( parser=lambda_event_parser( threshold=110 ) ) \r\n\r\nfor event in file.events:\r\n    event.filter( order=1, cutoff=2000 )\r\n    event.parse( parser=SpeedyStatSplit( min_gain_per_sample=0.50 ) )\r\n    event.apply_hmm( hmm=Bifurcator )\r\n    event.plot( color='hmm' )\r\n    plt.show()\r\n```\r\n\r\nYou'll see that I had to import Bifurcator from the hmm module. By just using the event apply_hmm method, I can apply the hmm with minimal effort, and by coloring by 'hmm', segments will now be colored according to which hidden state in the HMM they correspond to. \r\n\r\nEvent objects also have the properties start, end, duration, mean, std, and n (number of segments after segmentation has been performed). \r\n\r\n# Segments\r\n\r\nSegments are short sequences of current samples, usually which appear to be from the same distribution. They are the core place where data are stored, as usually an event is analyzed by the metadata stored in each state. Segments have the attributes current, which stores the raw current samples, in addition to mean, std, duration, start, end, min, and max. They do not have any core methods.\r\n\r\nIf storing the raw sequence of current samples is too memory intensive, there are two ways to get rid of the current attribute. \r\n\r\n1) Initialize a MetaSegment object, instead of a Segment one, and feed in whatever statistics you'd like to save. This will prevent the current from ever being saved to a second object. For this example, lets assume you have a list of starts and ends of segments in an event, such as loading them from a cache.\r\n\r\n```\r\nevent = Event( current=[...], start=..., file=... )\r\nevent.segments =  [ MetaSegment( mean=np.mean( event.current[start:end] ),\r\n                                 std=np.std( event.current[start:end] ),\r\n                                 duration=(end-start)/100000 ) for start, end in zip( starts, ends ) ]\r\n```\r\n\r\nIn this example, references to the current are not stored in both the event and the segment, which may save memory if you wish to not store the raw current after analyzing a file. The duration here is divided by 100,000 because abf files store 100,000 samples per second, and we wished to convert from the integer index of the start and end to the second index of the start and end.\r\n\r\n2) If you have the memory to store the references, but don't want to accumulate them past a single event, you can parse a file normally, and produce normal segments, then call the function to_meta() to turn them into MetaSegments. This does not require any calculation on the user part, but does require the segment have contained all current samples at one point.\r\n\r\n```\r\nevent = Event( current=[...], start=..., file=... )\r\nevent.parse( parser=SpeedyStatSplit() )\r\nfor segment in event.segments:\r\n    segment.to_meta() \r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}